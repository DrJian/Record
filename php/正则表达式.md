## 正则表达式中的派别

### Posix标准(Portable Operating System Interface)
----
在操作系统发展初期，awk,grep等程序对正则表达式的支持都有所区别，因此，用户在使用过程中就会出现各种问题与不爽，因此，需要一套统一的标准进行约束，正则表达式也是Posix中的一种。

在Posix标准下，正则表达式被分为两种，BRE（Basic Regular Expressions）与ERE（Extended Regular Expressions）。所有Posix标准下的程序支持其中一种即可。
![](http://img03.taobaocdn.com/imgextra/i3/581166664/TB2uVx6bpXXXXaDXpXXXXXXXXXX_!!581166664.png)

想要在BRE下使用+ ?需要加\即\+ \?

- 使用BRE语法的命令有：grep、ed、sed、vim
- 使用ERE语法的命令有：egrep、awk、emacs

但是部分命令支持ERE，通过修改参数，grep命令可以支持BRE,ERE，也可以支持Perl标准下正则


### Posix可没有\d \w
----
大家平常都喜欢用\d \w，不过，在posix中，sry，用不了，因为这些元字符是在Perl中推出的，明明就是两回事，在Posix相似的倒是定义了一些shorthand

![](http://upload-images.jianshu.io/upload_images/1653971-1773c26b782ff5cd.png?imageMogr2/auto-orient/strip)

图中列出了他们与Perl中\d等对应关系

**语法上，Posix中不用//这种将regex包裹起来，直接写正则就好了**

### Perl风格与PCRE
----
Perl(Practical Extraction and Reporting Language)实时抽取与汇报语言。本身的出现是为了格式化处理文本，所以内建了正则表达式。

发现Perl内置的正则非常好用，所以当年的Web开发者将这个东西挪过来，搞了一个名为PCRE(Perl Compatible Regular Expressions)的东西,一个从Perl中提取出来的更加轻量级的库，这个是基于Perl5的。目前绝大部分主流编程语言PHP Java C C++均使用这一正则引擎。

在PCRE中，我们就可以像Perl一样使用/regex/，以及元字符\d \w等。

## 基本使用
符号  | 语义
------------- | -------------
*  | 重复0次或多次
+  | 重复1次或多次
?  | 0个或1个
[a-zA-Z0-9] | 匹配包含括号内元素的字符串
a{2}| 匹配任何包含两个连续a的字符串
a{2,3}|任何包含2个或3个连续a
a{2,}|至少包含两个连续a
a$ | 以a结尾
^p  | 以p开头
[^] |任意不包含括号内元素的字符串
[^abc] | 任意不包含abc的字符串
a.a | 任意包含a，接下来是任意字符，接下来又是a的字符串
^.{2}$ | 任意只包含两个字符的字符串

使用两个斜线将匹配部分包含起来

/food*/匹配0个或多个food

### 一些好用的元字符
元字符|等价
----|---
\d| [0-9]
\D| [^0-9] 
\s| 空白字符(换行、换页、制表符和空格等)
\S| 非空白字符
$| 匹配行尾
^| 匹配行首
.| 匹配除换行之外所有字符
\w|[a-zA-Z0-9_]
\W|忽略下划线和字母数字字符

### 修饰符
修饰符|语义
-----|----
i | 不区分大小写  abc/i 匹配abc,不区分大小写
g | 查找全部出现，完成全局搜索
m | 开启多行匹配，$ ^ 会分别对应为每一行，其他无影响

## 高级用法与概念
### 子组
---
正则中，我们会需要将一组相关的信息放置于一起，或者处于其他目的，这个时候用()括起来，括号中的部分即在同一子组中，我们会对子组进行组号分配，从左到右，从1开始，依次赋值。

举例，被匹配字符串'JavaScript' 正则'/(Java)(Script)/'
这个正则中有两个结果，1->Java 2->Script

#### 跳过组捕获
如果我不想再结果集中使用组，怎么办呢？这时我们可以跳过分组，在左括号后使用?:即可
'/(?:Java)(Script)/' 结果中只有1->Script

### 反向引用
---
如果我想使用之前匹配到的组的信息，这个时候可以使用反向引用，\分组数字编号
例如，/(?:Java)(Script)\1/'/ 可以匹配JavaScriptJava
### 贪婪模式与非贪婪模式、回溯
---

对于所有的量词修饰符 ? + *都是优先匹配的，可以理解为贪婪，即先满足自己的匹配条件。

这里举一个例子说明贪婪与非贪婪的差别

待匹配字符串php7

#### 贪婪模式
/.*7/
1. .*拿到了控制权，发现是*,优先匹配，匹配第一个p，success
2. .*依旧拥有控制权，匹配h，吞进去
3. .*又一次吞入了p
4. .*又一次吞入了7
5. .*发现已经到了结尾的位置(正常如果\n换行也会触发)，没什么可吞的东西了，将控制权交给了7
6. 7发现自己已经到了末尾位置，没有可以匹配的机会，于是尝试进行回溯，控制权转交给.*
7. .*退回一个字符，将控制权交给7
8. 7发现这个字符是7，匹配success
9. 结束

整个匹配过程发生了一次回溯

#### 非贪婪模式
**在量词后面加一个?，即转为非贪婪模式(懒惰模式)**

/.*?7/
1. .*?成为了不优先，所以将控制权交给下了7
2. 7去匹配p，失败，这个时候需要查找可供回溯的状态，将控制权交给.*
3. .*匹配p成功，吞入p，推进到下一个位置，将控制权再次交给7
4. 7匹配h失败，查找可回溯位置，将控制权交给.*
5. .*吞入h，交给7
6. 7匹配p失败，交给.*
7. .*匹配p成功，推进到下一位置
8. 7匹配7成功
9. 结束

整个过程发生了三次回溯

### 断言
---
对于断言的概念，只需要明确一点，断言匹配的是满足条件的一个位置，而不是某个字符

这里举例说明
(?=)正预测
(?<=)正回顾
(?!)负预测
(?<!)负回顾

## 一些正则的应用

### 防盗链
^((.*\.)?(xxx\.(com|com\.cn|cn)|xx\.com)|localhost|\d{1,3}(\.\d{1,3}){3})(:\d+)?$

### 强密码
(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：

^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$  

### 中文字符的正则表达式：
[\u4e00-\u9fa5]


## 正则表达式引擎
DFA(确定性有穷自动机) NFA(非确定性有穷自动机)


## 参考资料
1. [PHP手册正则相关](http://php.net/manual/zh/regexp.introduction.php)
2. 